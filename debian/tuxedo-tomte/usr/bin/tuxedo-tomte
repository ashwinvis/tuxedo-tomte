#!/usr/bin/perl -w
use strict qw(vars subs);
use warnings;

use File::Copy;

# for OLED backlight and edid decrypt
use FindBin qw($Bin);
use lib "$Bin/.";
use Parse::EDID qw(parse_edid);

# for debugging
use Data::Dumper;

# make sure this is the only running instance
use Fcntl qw(:flock);
open our $file, '<', $0 or die $!;
flock $file, LOCK_EX|LOCK_NB or die "Another instance is already running\n";

my $grubFile = '/etc/default/grub';
my $logDir = '/var/log/tomte/';
my $logFile = $logDir.'tomte.log';
my $LOGFILE;
my $noLogFile = 1;		# 0 = logFile ok, 1 = no logFile
my $noConfigFile = 1;	# 0 = configfile ok, 1 = no configfile
my $configDir = '/etc/tomte/';
my $configFile = $configDir.'tomte.cfg';
my $shareDir = '/usr/share/tuxedo-tomte/';
my $reposList = $shareDir.'repolist.txt';
my $distribution;
my $distributionVersion;
my $FAI = 0;
my $networkSearchDone = 0;

my $lspciOutput = `lspci -vn`;
my $boardnameFilename = "/sys/class/dmi/id/board_name";
my $boardname;
$boardname = readFileReturnLine($boardnameFilename);

my $boardvendorFilename = "/sys/class/dmi/id/board_vendor";
my $boardvendor;
$boardvendor = readFileReturnLine($boardvendorFilename);

my $sysvendorFilename = "/sys/class/dmi/id/sys_vendor";
my $sysvendor;
$sysvendor = readFileReturnLine($sysvendorFilename);

# for checking md5sums for corefix
use Digest::MD5 qw(md5_hex);
my %initrdHashSaved;
my %initrdHashFiles;
my $md5ConfigDir = '/etc/tomte/';
my $md5Store = $md5ConfigDir.'md5sums';

# for desktop messages
my $sessionID = readFileReturnLine('/proc/sys/kernel/random/boot_id');
$sessionID =~ /(.{7})/;
$sessionID = hex($1);
my $longInstall = 0;
my $restartSystem = 0;

###############################################################################
# Argument values given to script
#
my %argValue = (
	command => '',
	module => '',
);




###############################################################################
# initial definition of post configuration modules
#   command		the command to be executed on the system
#   trigger		'1' / 'undef' wether the command should be executed
#   status		'undef' / 'failed' wether the command execution failed
#
my %postConfProgram = (
	updateGrub => {
		command => 'update-grub',
		trigger => 0,
		status => 'undef',
		description => 'reconfigures grub according to grub file',
	},
	updateInitramfs => {
		command => 'update-initramfs -u -k all',
		trigger => 0,
		status => 'undef',
		description => 'updates initramfs',
	},
);


###############################################################################
# list of supported OS versions
# with repective repo entries
#
my %supportedOS = (
	Ubuntu => {
		versions => {
			"18.04" => {
				name => 'bionic',
			},
			"20.04" => {
				name => 'focal',
			},
		},
	},
);


my %tuxedo_repos = (
	"Ubuntu 18.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb http://deb.tuxedocomputers.com/ubuntu bionic main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb http://oibaf.tuxedocomputers.com/ubuntu bionic main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb http://graphics.tuxedocomputers.com/ubuntu bionic main'],
		},
		name => 'bionic',
	},
	"Ubuntu 20.04" => {
		deb => {
			filename => '/etc/apt/sources.list.d/tuxedo-computers.list',
			content => ['deb http://deb.tuxedocomputers.com/ubuntu focal main'],
		},
		oibaf => {
			filename => '/etc/apt/sources.list.d/oibaf-tuxedo.list',
			content => ['deb http://oibaf.tuxedocomputers.com/ubuntu focal main'],
		},
		graphics => {
			filename => '/etc/apt/sources.list.d/graphics-tuxedo.list',
			content => ['deb http://graphics.tuxedocomputers.com/ubuntu focal main'],
		},
		name => 'focal',
	},
);



my %tuxedo_mirrors = (
	"Ubuntu 18.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb http://packages.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic main restricted universe multiverse',
'deb http://packages.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu bionic-security main restricted universe multiverse',
'deb http://packages.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu bionic-updates main restricted universe multiverse'],
		},
		name => 'bionic',
	},
	"Ubuntu 20.04" => {
		mirrors => {
			filename => '/etc/apt/sources.list',
			content => ['deb http://packages.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal main restricted universe multiverse',
'deb http://packages.tuxedocomputers.com/ubuntu/mirror/security.ubuntu.com/ubuntu focal-security main restricted universe multiverse',
'deb http://packages.tuxedocomputers.com/ubuntu/mirror/archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse'],
		},
		name => 'focal',
	},
);



###############################################################################
#
# For each new module add an entry into:
# - %origConfModules
# - checkRequirements()
# - the section with all the modules subroutines

# For changes in %origConfModules make the modifications also in:
# - writeConfigFile()

###############################################################################
# initial definition for all origConfModules/packages
# defined by a 'short name' which is the name without '-'
# e.g. no-boot-on-battery = nobootonbattery
#
#   name			name of package or name of solution,
#					is 'short name' without '-'
#   version			the package or solution version
#					rises if the solution changes
#   installed		'no' not installed / 'yes' installed / 'failed' failed to
#					install, 'undef' if unknown
#   blocked			'yes' or 'no' will not be configured on upgrade, install
#					or deinstall, 'undef' if unknown
#   required		'yes' or 'no' the system requirements are met
#					'undef' if unknown
#					'prerequisite' if essentially needed to be present before
#					anything else
#   hwid			the environment (HW or SW) are in a certain defined state
#					rises if additional HW gets support
#   package			'yes' or 'no', there is a deb or rpm package as a solution
#   				if there are seceral packages to be installed then 'no'
#   fainame			the name to give to FAI to install a certain package
#   description		A description about the module for the user
#   postconf		command module to execute after installation of module,
#					empty if none, the command of the module is defined in
#					$postConfModule{$postconf}{command}
#	upgrade			if the system determines this is an upgrade then 'yes'
#					else 'no'
#					don't set the value yourself, it will be determined by
#					Tomte
#	upgraded		if module was upgraded 'yes', else 'no'
#	reconfigure		if set to 'always' will always reconfigure if fix detected
#
my %origConfModules = (
	i8042fix => {
		name => 'i8042-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fix for no-keyboard-present after boot on XC1711',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
	},
	nobootonbattery => {
		name => 'no-boot-on-battery',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fix for no-boot-on-battery on BA15',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
    },
	amdxhcihcdusbquirksuspendfix => {
		name => 'amd-xhci-hcd-usb-quirk-suspend-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Fix for some AMD devices where the xhci_hcd driver causes a jump out of suspend immediately on entering suspend',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
	},
	amdgpuwithnvidiafix => {
		name => 'amd-gpu-with-nvidia-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Enables activation of discrete NVIDIA graphics on devices with built-in AMD graphics. Also enables switching between both with prime-select',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	tuxedocontrolcenter => {
		name => 'tuxedo-control-center',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'TUXEDO Control Center Application',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedokeyboard => {
		name => 'tuxedo-keyboard',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Keyboard & keyboard backlight driver for TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	nokeyboardaftersuspendfix => {
		name => 'no-keyboard-after-suspend-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 2,
		package => 'no',
		fainame => '',
		description => 'Fixes no keyboard after suspend problem',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
	},
	backlightfix => {
		name => 'backlight-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes backlight issues for DX1708 with AUO Model 12701 displays',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	tuxedorepos => {
		name => 'tuxedo-repos',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'prerequisite',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Adds the TUXEDO repositories',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedomirrors => {
		name => 'tuxedo-mirrors',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'prerequisite',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Adds TUXEDO maintained Ubuntu repositories',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	corefix => {
		name => 'core-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'ACPI mod for accurate cores recognition',
		postconf => 'updateInitramfs',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	threegfix => {
		name => 'threeg-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Configuration needed to operate Huawei-ME936',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	elantechtouchpadfix => {
		name => 'elantech-touchpad-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes non working Elantech touchpad',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
	},
	tuxedotouchpadswitch => {
		name => 'tuxedo-touchpad-switch',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Adds hardware enable/disable for touchpads with LED indicator on several TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedonvmefix => {
		name => 'tuxedo-nvme-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Removes sleep bug on Kingston A2000 NVME devices by updating the firmware',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	tuxedokeyboardite => {
		name => 'tuxedo-keyboard-ite',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Keyboard back-light driver for ITE devices',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	fingerprintreader => {
		name => 'fingerprint-reader',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Packages needed for fingerprint reader to work on certain TUXEDO notebooks',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedomicfix1 => {
		name => 'tuxedo-micfix1',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Kernel audio module which fixes different issues with audio output',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	mesautils => {
		name => 'mesa-utils',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'The Mesa 3D Graphics Library',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedorestoreaudiofix => {
		name => 'tuxedo-restore-audio-fix',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Systemd service which rescans for missing audio devices',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	kernel => {
		name => 'kernel',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required kernel versions',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	nvidiadriver => {
		name => 'nvidia-driver',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Required Nvidia drivers',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	cracklibruntime => {
		name => 'cracklib-runtime',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'yes',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Builds password dictionary databases',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	amdgpudkms => {
		name => 'amdgpu-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Enables AMD GPU and display to share configuration information',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	r8168dkms => {
		name => 'r8168-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Linux device driver for several Realtek Ethernet controllers',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	tuxedooledbrt => {
		name => 'tuxedo-oled-brt',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Workaround to control OLED display brightness using dbus and xrandr',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => 'yes',
	},
	apportfix => {
		name => 'apport-fix',
		version => 2,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Workaround for undefined problems with apport',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	realtekr8125dkms => {
		name => 'realtek-r8125-dkms',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'yes',
		fainame => '',
		description => 'Linux device driver for several Realtek Ethernet controllers',
		postconf => '',
		upgrade => '',
		upgraded => '',
		reconfigure => '',
		restart => '',
	},
	amdgpubacklightauxoff => {
		name => 'amdgpu-backlight-aux-off',
		version => 1,
		installed => 'no',
		blocked => 'no',
		required => 'no',
		hwid => 1,
		package => 'no',
		fainame => '',
		description => 'Fixes backlight control',
		postconf => 'updateGrub',
		upgrade => '',
		upgraded => '',
		reconfigure => 'always',
		restart => 'yes',
	},

);


# hash to load the configfile
# is a copy from origConfModules to evade undefined values
my %localConfModules = %origConfModules;


# empty hash, will be filled with successfully installed modules
# as hashes: {modulename}{status}
# where status should be "success" or "failed"
#
my %configuredModules;


###############################################################################
# reads a file and returns an array with the lines
# chomps the linefeed
# returns undef if file can't be opened
#
sub readFileReturnLines {
	my $file = shift;
	my $FH;
	my @lines;
	if ( open $FH, "<", $file ) {
		chomp(@lines = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("no $file present or unable to open the file for reading");
		return;
	}
	return @lines;
}



###############################################################################
# reads a file and returns a line
# chomps the line
# returns undef if file can't be opened
#
sub readFileReturnLine {
	my $file = shift;
	my $FH;
	my $line;
	if ( open $FH, "<", $file ) {
		chomp($line = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("no $file present or unable to open the file for reading");
		return;
	}
	return $line;
}




###############################################################################
# find OS name and version and put them into $distribution and
# $distributionVersion
#
sub readOSData {
	my $osReleaseFile = '/etc/os-release';
	my @osReleaseLines;

	@osReleaseLines = readFileReturnLines($osReleaseFile);

	if ( !@osReleaseLines ) {
		print "Can't determine the operating system\n";
		exit (0);
	}
	foreach ( @osReleaseLines ) {
		if ( $_ =~ /^NAME=/ ) {
			$_ =~ /NAME=\"(.*)\"/;
			$distribution = $1;
		}
		if ( $_ =~ /^VERSION_ID=/ ) {
			$_ =~ /VERSION_ID=\"(.*)\"/;
			$distributionVersion = $1;
		}
	}
}




###############################################################################
# returns the brand of the CPU (AMD or Intel)
sub cpuBrand {
	my $infos;
	if ( open(FH, '<', '/proc/cpuinfo') ) {
		local $/;
		$infos = <FH>;
		close FH;
		if ($infos =~ /vendor_id\s*:\s*AuthenticAMD/) {
			return ('AMD');
		}
	}
	return ('Intel');
}



###############################################################################
# checks the list of supported distributions and versions and returns
# 1 if supported
# 0 if not
#
sub isOSSupported {
	if (exists($supportedOS{$distribution}{versions}{$distributionVersion})) {
		return (1);
	}
	return (0);
}


###############################################################################
# check basic requirements the system should fullfill and
# install missing parts
#
sub prerequisites {
	reconfigureSingleModule('tuxedo-repos');
	reconfigureSingleModule('tuxedo-mirrors');
}



###############################################################################
# check whether the module is required for the system
# checks only for hardware
#
sub checkRequirements {
	my $FH;
	my $biosVersion;

	# check values for each module
	if ($boardname =~ /PB50_70DFx,DDx/) {
		$origConfModules{i8042fix}{required} = 'yes';
		printLog('detected i8042-fix issue');
	}

	if ($boardname =~ /PF5PU1G/) {
		$origConfModules{nobootonbattery}{required} = 'yes';
		printLog('detected no-boot-on-battery issue');
	}

	if (($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /NL5xRU/) ||
		($boardname =~ /EDUBOOK1502/) ||
  		($boardname =~ /AURA1501/)) {
		$origConfModules{amdxhcihcdusbquirksuspendfix}{required} = 'yes';
		printLog('detected amd-xhci-hcd-usb-quirk-suspend-fix issue');
	}

	if (($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/)) {
		if ($distributionVersion =~ /18.04/) {
			$origConfModules{amdgpuwithnvidiafix}{required} = 'yes';
			printLog('detected amd-gpu-with-nvidia-fix issue');
		}
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /PB50_70DFx,DDx/) ||
   		($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /N141CU/) ||
		($boardname =~ /N150CU/) ||
   		($boardname =~ /NH5xAx/) ||
   		($boardname =~ /NL5xRU/) ||
		($boardname =~ /AURA1501/) ||
		($boardname =~ /EDUBOOK1502/) ||
		($boardname =~ /PB50_70DFx,DDx/) ||
		($boardname =~ /NS50MU/)) {
		$origConfModules{nokeyboardaftersuspendfix}{required} = 'yes';
		printLog('detected no-keyboard-after-suspend-fix issue');
	}

	if ($boardname =~ /X35R/) {
		$origConfModules{elantechtouchpadfix}{required} = 'yes';
		printLog('detected elantech-touchpad-fix issue');
	}

	if (($boardname =~ /LAPQC71A/) ||
		($boardname =~ /LAPQC71B/) ||
		($boardname =~ /PF5PU1G/) ||
		($boardname =~ /PF5PU1G/) ||
		($boardname =~ /POLARIS1501A1650TI/) ||
		($boardname =~ /POLARIS1501A2060/) ||
		($boardname =~ /POLARIS1501I1650TI/) ||
		($boardname =~ /POLARIS1501I2060/) ||
		($boardname =~ /POLARIS1701A1650TI/) ||
		($boardname =~ /POLARIS1701A2060/) ||
		($boardname =~ /POLARIS1701I1650TI/) ||
		($boardname =~ /POLARIS1701I2060/) ||
		($boardname =~ /PULSE1401/) ||
		($boardname =~ /PULSE1501/) ||
		($boardname =~ /TRINITY1501I/) ||
		($boardname =~ /TRINITY1501I/) ||
		($boardname =~ /PHxTxX1/) ||
		($boardname =~ /PH4TQx1/) ||
		($boardname =~ /GMxNGxx/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxMGxx/))
	{
		$origConfModules{tuxedotouchpadswitch}{required} = 'yes';
		printLog('detected tuxedo-touchpad-switch issue');
	}

	if ($boardname =~ /(N8xEJEK)/) {
		if (isDisplayPresent("AUO Model 12701 Serial Number 585803690")) {
			$origConfModules{backlightfix}{required} = 'yes';
			printLog('detected backlight-fix issue');
		}
	}

	# get the BIOS version
	# deactivated but could be useful if version changes in the future
	# $main::biosVersion = `dmidecode -s bios-version`;
	$main::biosVersion = '1.07.04NBC';
	$main::biosVersion =~ s/\s//g;
	if ($boardname =~ /NH5xAx/) {
		# if ($main::biosVersion =~ m/1\.07\.04NBC/) {
		$origConfModules{corefix}{required} = 'yes';
		printLog('detected core-fix issue');
		#}
	}

	# if Threeg Huawei ME936 device found
	my $lsusb = `lsusb -d 12d1:15bb`;
	if ($lsusb =~ /ME936/) {
		$origConfModules{threegfix}{required} = 'yes';
		printLog('detected threeg-fix issue');
	}

	if (($boardname =~ /X170SM/) ||
		($boardname =~ /PCx0Dx_GN20/) ||
		($boardname =~ /GMxZGxx/) ||
		($boardname =~ /GMxTGxx/)) {
		$origConfModules{tuxedokeyboardite}{required} = 'yes';
		printLog('detected tuxedo-keyboard-ite issue');
	}

	# get vendor text from vendor ID:device ID
	my @tuxedonvmefixDevices = ('2646:2263');
	if ( findPciDevice($lspciOutput, @tuxedonvmefixDevices) ) {
		$origConfModules{tuxedonvmefix}{required} = 'yes';
		printLog('detected tuxedo-nvme-fix issue');
	}

	my $fingerprintLsUsb = `lsusb`;
	my @fingerprintRegExp = (
		qr/147e:100[0123]/,
		qr/147e:20(15|16|20)/,
		qr/147e:300[01]/,
		qr/147e:500[23]/,
		qr/0483:201[56]/,
		qr/1c7a:0603/);
	foreach my $fpkey (map { $fingerprintLsUsb =~ $_ } @fingerprintRegExp) {
		$origConfModules{fingerprintreader}{required} = 'yes';
		printLog('detected fingerprint-reader issue');
		last;
	}

	my @tuxedomicfix1Devices = (
		'1558:67e1', 
		'1558:8562', 
		'1558:1401', 
		'1558:1404', 
		'1558:14a1', 
		'1558:40a1', 
		'1558:50f0', 
		'1558:8686', 
		'1558:4018', 
		'1558:a500', 
		'1558:51a1',
		'1558:67e5',
		'1558:65e5'
	);
	if ( findPciDevice($lspciOutput, @tuxedomicfix1Devices) ) {
		$origConfModules{tuxedomicfix1}{required} = 'yes';
		printLog('detected tuxedo-micfix1 issue');
	}

	if ($boardname =~ m/N350TW/) {
		$origConfModules{tuxedorestoreaudiofix}{required} = 'yes';
		printLog('detected tuxedo-restore-audio-fix issue');
	}

	# get class codes from vendor ID
	my $nvidiaDevice = `lspci -nd 10de:`;
	if ($nvidiaDevice =~ /030[02]:/) {
		$origConfModules{nvidiadriver}{required} = 'yes';
		printLog('detected nvidia-driver issue');
	}

	if ((cpuBrand() eq 'AMD') &&
		($distributionVersion =~ /20.04/)) {
		$origConfModules{amdgpudkms}{required} = 'yes';
		printLog('detected amd-gpu issue');
	}
	if ($boardname =~ m/NHxxRZQ/) {
		$origConfModules{r8168dkms}{required} = 'yes';
		printLog('detected r8168-dkms issue');
	}
	if (isDisplayPresent("SDC Model 41001 Serial Number 0")) {
		$origConfModules{tuxedooledbrt}{required} = 'yes';
		printLog('detected tuxedo-oled-brt issue');
	}
	if (isPackageInstalled('apport')) {
		# apportfix will always be installed as a workaround
		$origConfModules{apportfix}{required} = 'yes';
		printLog('detected apport-fix issue');
	}
	if (($boardname =~ m/GMxMGxx/) ||
		($boardname =~ m/GMxNGxx/) ||
		($boardname =~ m/GMxZGxx/) ||
		($boardname =~ m/GMxTGxx/)) {
		$origConfModules{realtekr8125dkms}{required} = 'yes';
		printLog('detected realtek-r8125-dkms issue');
	}
	if ($boardname =~ m/GMxNGxx/) {
		if (isDisplayPresent("BOE Model 2423 Serial Number 0")) {
			$origConfModules{amdgpubacklightauxoff}{required} = 'yes';
			printLog('detected amdgpu-backlight-aux-off issue');
		}
	}

}



###############################################################################
# returns true if the PCI device or subdevice was found
# parameter is an array of PCI devices (RegExp are allowed)
#
sub findPciDevice {
	my ($lspciList, @pciDevices) = @_;
	my $pciDevice;
	foreach $pciDevice (@pciDevices) {
		if ($lspciList =~ /$pciDevice/) {
			return (1);
		}
	}
	return (0);
}


###############################################################################
###############################################################################
###############################################################################
# each configure one module from %confModules
# they set 'installed' status and $postConfModule trigger
#
# for keyboard not present on boot
# for XC1711 on all distributions
# - PB50_70DFx,DDx
#
sub i8042fix() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("i8042.nopnp");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# for not being able to boot if system is on battery
# affects BA15
# - PF5PU1G
#
sub nobootonbattery() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("iommu=soft");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Fix for some AMD devices where the xhci_hcd driver causes a jump out of
# suspend immediately on entering suspend
# - POLARIS1501A1650TI
# - POLARIS1501A2060
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - PULSE1401
# - PULSE1501
# - AURA1501/NL5xRU
# - EDUBOOK1502
#
sub amdxhcihcdusbquirksuspendfix() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("xhci_hcd.quirks=1073741824");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				$postConfProgram{updateGrub}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Enables activation of discrete NVIDIA graphics on devices with built-in AMD
# graphics. Also enables switching between the two with prime-select
# affects:
# - POLARIS1701A1650TI
# - POLARIS1701A2060
# - POLARIS1501A1650TI
# - POLARIS1501A2060
#
sub amdgpuwithnvidiafix() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $fileName = '/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf';
	my $niceTime = getBackupFileTime();
	my $fileText = "# added by tuxedo-tomte ".$niceTime."\n".
		"Section \"OutputClass\"\n".
		"\tIdentifier \"nvidia\"\n".
    	"\tMatchDriver \"nvidia-drm\"\n".
    	"\tDriver \"nvidia\"\n".
    	"\tOption \"AllowEmptyInitialConfiguration\"\n".
    	"\tModulePath \"/usr/lib/x86_64-linux-gnu/nvidia/xorg\"\n".
    	"\tOption \"PrimaryGPU\" \"Yes\"\n".
		"EndSection\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = createFile($fileName, $fileText);
		if ($retval == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$origConfModules{$module}{installed} = "yes";
		$origConfModules{$module}{upgraded} = "yes";
		addToConfiguredModules($module, "success");
	}
	if ($action eq 'remove') {
		printLog("removing $module", 'TL');
		unlink glob ("/usr/share/X11/xorg.conf.d/00-tuxedo-nvidia-amdgpu-fix.conf_*");
		if (backupFile($fileName)) {
			unlink($fileName);
		} else {
			printLog('can\'t remove fix, it seems to be gone already', 'TL');
		}
		$origConfModules{$module}{installed} = 'no';
		$origConfModules{$module}{upgraded} = 'yes';
		addToConfiguredModules($module, 'success');
	}
}


###############################################################################
# TUXEDO Control Center application
#
sub tuxedocontrolcenter() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Keyboard & keyboard backlight driver for TUXEDO notebooks
#
sub tuxedokeyboard() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}





###############################################################################
# Fix for TUXEDO Notebooks, fixes no keyboard present after suspend on
# - XC1711
# - XUX711
# - NH5xAx
# - AURA1501/NL5xRU
# - PB50_70DFx,DDx
# - N150CU
# - N141CU
# - XC15 
# - IBS15v6
# - EDUBOOK1502
#
sub nokeyboardaftersuspendfix() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("i8042.reset", "i8042.nomux", "i8042.nopnp", "i8042.noloop");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Fixes backlight issue with AUO Model 12701 displays on
# - DX1708 
#
sub backlightfix() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("i915.enable_dpcd_backlight=1");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Adds the TUXEDO repos to the system
#
sub tuxedorepos() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $exitStatus;
	my $output;

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = createRepos(\%tuxedo_repos);
		if ($retval == 2) {
			$retval2 = addRepoKey();
		}
		if (($retval == 0) && ($retval2 == 0)) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if ($retval == 1) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifcations on repos');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				if (!$FAI) {
					checkNetwork();
					$output = `pkcon refresh`;
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages');
						printLog("returned error code: $exitStatus");
						if ($exitStatus == 7) {
							printLog('possible network problems');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog("success: update packages");
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		if ( $localConfModules{$module}{version} == 1 ) {
			printLog("uprading $origConfModules{$module}{name}");
			backupFile('/etc/apt/sources.list');
			$retval = createRepos();
			if ($retval == 0) {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			} else {
				if ($retval == 1) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "nothingToDo");
					printLog('did no modifcations on repos');
				} else {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					# update of repos has to be immediate for possible later package
					# installation
					checkNetwork();
					$output = `pkcon refresh`;
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages');
						printLog("returned error code: $exitStatus");
						if ($exitStatus == 7) {
							printLog('possible network problems');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog('success: update packages');
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Adds the TUXEDO mirrors to the system
#
sub tuxedomirrors() {
	my $module = shift;
	my $action = shift;
	my $retval;
	my $retval2;
	my $retval3;
	my $exitStatus;
	my $output;

	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = createRepos(\%tuxedo_mirrors);
		$retval3 = cleanSourcesList();
		if ($retval == 2) {
			$retval2 = addRepoKey();
		}
		if (($retval == 0) && ($retval2 == 0)) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			if (($retval == 1) && ($retval3 == 0)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "nothingToDo");
				printLog('did no modifcations on mirrors');
			} else {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				# update of repos has to be immediate for possible later package
				# installation
				if (!$FAI) {
					checkNetwork();
					$output = `pkcon refresh`;
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages');
						printLog("returned error code: $exitStatus");
						if ($exitStatus == 7) {
							printLog('possible network problems');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog("success: update packages");
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'upgrade') {
		if ( $localConfModules{$module}{version} == 1 ) {
			printLog("uprading $origConfModules{$module}{name}");
			backupFile('/etc/apt/sources.list');
			$retval = createRepos();
			if ($retval == 0) {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			} else {
				if ($retval == 1) {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					addToConfiguredModules($module, "nothingToDo");
					printLog('did no modifcations on mirrors');
				} else {
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
					# update of repos has to be immediate for possible later package
					# installation
					checkNetwork();
					$output = `pkcon refresh`;
					$exitStatus = $?/256;
					if ($exitStatus != 0) {
						printLog('failed: update packages');
						printLog("returned error code: $exitStatus");
						if ($exitStatus == 7) {
							printLog('possible network problems');
						}
						addToConfiguredModules($module, "failed");
					} else {
						printLog('success: update packages');
						addToConfiguredModules($module, "success");
					}
				}
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Adds the core-fix for certain BIOS versions on certain mainboards
#
sub corefix() {
	my $module = shift;
	my $action = shift;
	if ($main::biosVersion eq "") {
		printLog("BIOS version empty");
		$origConfModules{$module}{installed} = "failed";
		addToConfiguredModules($module, "failed");
		return(0);
	}
	my $amlHookScript = 'tuxedo-corefix-clevo-nh5xax';
	my $amlHookScriptOrig = $shareDir.$amlHookScript;
	my $amlHookDirDest = '/etc/initramfs-tools/hooks/';
	my $amlHookScriptDest = $amlHookDirDest.$amlHookScript;
	my %amlFile = (
		'1.07.04NBC' => 'nh5xax-1.aml',
	);
	my $amlFileOrig = $shareDir.$amlFile{$main::biosVersion};
	my $amlFileDirDest = '/lib/firmware/tuxedo-corefix-clevo-nh5xax/';
	$amlFile{$main::biosVersion} =~ s/-\d*//;
	my $amlFileDest = $amlFileDirDest.$amlFile{$main::biosVersion};

	if ($action eq 'install') {
		if (($argValue{command} eq 'configure') || ($argValue{command} eq 'reconfigure')) {
			messageLongInstall();
			printLog("applying $origConfModules{$module}{name}");
			mkdir($amlFileDirDest, 0644) unless(-d $amlFileDirDest);
			copy($amlFileOrig, $amlFileDest);
			mkdir($amlHookDirDest, 0644) unless(-d $amlHookDirDest);
			copy($amlHookScriptOrig, $amlHookScriptDest);
			chmod 0700, $amlHookScriptDest;

			if ((-e $amlFileDest) and (-e $amlHookScriptDest)) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$postConfProgram{updateInitramfs}{trigger} = 1;
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
		}
	}
	if ($action eq 'upgrade') {
		# not implemented yet
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Fixes problem with Elantech touchpad
# affects InfinityBook 14 v2
# - X35R
#
sub elantechtouchpadfix() {
my $module = shift;
my $action = shift;
my @kernel_parameters = ("psmouse.elantech_smbus=0");
my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
        if ($retval < 0) {
            $origConfModules{$module}{installed} = "failed";
            addToConfiguredModules($module, "failed");
        } else {
            $origConfModules{$module}{installed} = "yes";
            $origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
            	addToConfiguredModules($module, "success");
            	$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
        }
    }
    if ($action eq 'upgrade') {
        printLog("upgrading $origConfModules{$module}{name}");
        $retval = insertGrub($module, \@kernel_parameters);
        if ($retval < 0) {
            $origConfModules{$module}{installed} = "failed";
            addToConfiguredModules($module, "failed");
        } else {
            $origConfModules{$module}{installed} = "yes";
            $origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
            	addToConfiguredModules($module, "success");
            	$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
        }
    }
    if ($action eq 'remove') {
        # not implemented yet
    }
}



###############################################################################
# Creates a configuration to use Huawei-ME936
# - if USB device 12d1:15bb detected
#
sub threegfix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $fileName1 = '/etc/modprobe.d/huawei-me936.conf';
	my $fileName2 = '/lib/udev/rules.d/77-mm-huawei-configuration.rules';
	my $niceTime = getBackupFileTime();
	my $fileText1 = "# added by tuxedo-tomte ".$niceTime."\n".
		"options usbserial vendor=0x12d1 product=0x15bb\n";
	my $fileText2 = "# added by tuxedo-tomte ".$niceTime."\n".
		"ACTION==\"add|change\", SUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTR{idVendor}==\"12d1\", ATTR{idProduct}==\"15bb\", ATTR{bNumConfigurations}==\"3\", ATTR{bConfigurationValue}!=\"3\" ATTR{bConfigurationValue}=\"3\"\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval1 = createFile($fileName1, $fileText1);
		$retval2 = createFile($fileName2, $fileText2);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval1 = createFile($fileName1, $fileText1);
		$retval2 = createFile($fileName2, $fileText2);
		if ($retval1 == 0 || $retval2 == 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}


###############################################################################
# Uniwill touchpad LED fix
#
sub tuxedotouchpadswitch() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Kingston A2000 NVME drives freezing after deep APST sleep fix
#
sub tuxedonvmefix() {
	my $module = shift;
	my $action = shift;
	my %nvmeDevice;
	my $nvmeDir;
	my $output;
	my $fwVersion = 'S5Z42109';
	my $nvmeUpdateSuccess = 0;
	my $nvmeFWPackageWasInstalled = 0;
	if (isPackageInstalled('tuxedo-nvme-fix')) {
		if (! deinstallPackage('tuxedo-nvme-fix')) {
			printLog('obsolete package tuxedo-nvme-fix was successfully removed');
		} else {
			printLog('could not remove obsolete package tuxedo-nvme-fix, will try again next time');
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
			return (0);
		}
	}
	if (($action eq 'install') || ($action eq 'upgrade')) {
		while ( defined ($nvmeDir = glob '/sys/class/nvme/*' )) {
			$nvmeDevice{$nvmeDir}{'device'} = $nvmeDir;
			$nvmeDevice{$nvmeDir}{'device'} =~ /.*(nvme.*)/;
			$nvmeDevice{$nvmeDir}{'device'} = '/dev/'.$1;
			$nvmeDevice{$nvmeDir}{'model'} = readFileReturnLine("$nvmeDir/model");
			$nvmeDevice{$nvmeDir}{'subdevice'} = readFileReturnLine("$nvmeDir/device/subsystem_device");
			$nvmeDevice{$nvmeDir}{'subvendor'} = readFileReturnLine("$nvmeDir/device/subsystem_vendor");
			$nvmeDevice{$nvmeDir}{'firmware'} = readFileReturnLine("$nvmeDir/firmware_rev");
		}
		foreach $nvmeDir ( keys %nvmeDevice ) {
			if (($nvmeDevice{$nvmeDir}{model} =~ /SA2000M8(?:25|50|100)0G/) &&
				($nvmeDevice{$nvmeDir}{subdevice} =~ /0x2263/) &&
				($nvmeDevice{$nvmeDir}{subvendor} =~ /0x2646/)) {
				printLog("nvme device on $nvmeDevice{$nvmeDir}{'device'}");
				if ($nvmeDevice{$nvmeDir}{firmware} lt $fwVersion) {
					printLog("firmware upgrade required");
					# firmware upgrade is required
					if (! isPackageInstalled('nvme-cli')) {
						if (! installPackage('nvme-cli')) {
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
					}
					if (isPackageInstalled('a2000-s5z42109')) {
						$nvmeFWPackageWasInstalled = 1;
					}
					if (installPackage('a2000-s5z42109')) {
						printLog("upload firmware on $nvmeDevice{$nvmeDir}{'device'}");
						$output = `nvme fw-download $nvmeDevice{$nvmeDir}{'device'} -f /lib/firmware/a2000/$fwVersion.bin`;
						if ($? != 0) {
							printLog('firmware could not be uploaded');
							printLog($output);
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						printLog("activate firmware on $nvmeDevice{$nvmeDir}{'device'}");
						$output = `nvme fw-activate $nvmeDevice{$nvmeDir}{'device'} --slot=1 --action=1`;
						if ($? != 0) {
							printLog('firmware could not be activated');
							printLog($output);
							$origConfModules{$module}{installed} = "failed";
							addToConfiguredModules($module, "failed");
							return (0);
						}
						$restartSystem = 1;
						$origConfModules{$module}{installed} = "yes";
						$origConfModules{$module}{upgraded} = "yes";
						printLog('nvme firmware was successfully updated');
						$nvmeUpdateSuccess = 1;
					} else {
						$origConfModules{$module}{installed} = "failed";
						addToConfiguredModules($module, "failed");
						return (0);
					}
				} else {
					printLog("firmware already installed on $nvmeDevice{$nvmeDir}{'device'}");
					$origConfModules{$module}{installed} = "yes";
					$origConfModules{$module}{upgraded} = "yes";
				}
			}
		}
		if ($nvmeUpdateSuccess) {
			addToConfiguredModules($module, "success");
		} else {
			addToConfiguredModules($module, "nothingToDo");
		}
		if (! $nvmeFWPackageWasInstalled) {
			deinstallPackage('a2000-s5z42109');
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# tuxedo-keyboard-ite
#
sub tuxedokeyboardite() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# fingerprint-reader
#
sub fingerprintreader() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packagefprintd;
	my $packagelibpam;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagefprintd = installPackage('fprintd');
		} else {
			$packagefprintd = 1;
		}
		if( ! isPackageInstalled('libpam-fprintd') ) {
			$wasInstalled = 0;
			messageLongInstall();
			$packagelibpam = installPackage('libpam-fprintd');
		} else {
			$packagelibpam = 1;
		}

		if( $packagefprintd && $packagelibpam ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages');
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# tuxedo-micfix1
#
sub tuxedomicfix1() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = 'yes';
				$origConfModules{$module}{upgraded} = 'yes';
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = 'failed';
				addToConfiguredModules($module, 'failed');
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages');
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# Mesa-utils
#
sub mesautils() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Rescans the pci bus to reactivate missing audio device
# - N350TW
#
sub tuxedorestoreaudiofix() {
	my $module = shift;
	my $action = shift;
	my $retval1;
	my $retval2;
	my $fileName = '/lib/systemd/system/restore-audiocards.service';
	my $fileText = "# added by tuxedo-tomte \n".
		"[Unit]\n".
		"Description=Rescan the PCI-Bus for missed audio cards\n".
		"After=alsa-restore.service\n".
		"\n".
		"[Service]\n".
		"Type=oneshot\n".
		"RemainAfterExit=false\n".
		"ExecStart=/usr/bin/bash -c 'echo auto >> /sys/devices/pci0000:00/0000:00:1f.3/power/control'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/devices/pci0000:00/0000:00:1f.3/remove'\n".
		"ExecStart=/usr/bin/sleep 1\n".
		"ExecStart=/usr/bin/bash -c 'echo 1 >> /sys/bus/pci/rescan'\n".
		"\n".
		"[Install]\n".
		"WantedBy=multi-user.target\n";
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval1 = createFile($fileName, $fileText);
		$retval2 = system('systemctl --now enable restore-audiocards.service');
		if ($retval1 == 0 || $retval2 != 0) {
			if ($retval2 != 0) {
				printLog('systemd could not initialize restore-audiocards.service');
			}
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
			$restartSystem = 1;
		}
	}
	if ($action eq 'upgrade') {
		printLog("no upgrade available yet for tuxedo-restore-audio-fix");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# kernel
#
sub kernel() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageLinuxGenericHwe1804;
	my $packageLinuxImageGenericHwe1804;
	my $packageLinuxHeadersGenericHwe1804;
	my $packageLinuxSignedGenericHwe1804;
	my $packageLinuxOem2004;
	my $packageLinuxFirmware;
	my $packageIntelMicrocode;
	if ($action eq 'install') {
		if ($distributionVersion =~ /18.04/) {
			# check if the package is already installed
			if( ! isPackageInstalled('linux-generic-hwe-18.04') ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageLinuxGenericHwe1804 = installPackage('linux-generic-hwe-18.04');
			} else {
				$packageLinuxGenericHwe1804 = 1;
			}
			if( ! isPackageInstalled('linux-image-generic-hwe-18.04') ) {
				$wasInstalled = 0;
				$packageLinuxImageGenericHwe1804 = installPackage('linux-image-generic-hwe-18.04');
			} else {
				$packageLinuxImageGenericHwe1804 = 1;
			}
			if( ! isPackageInstalled('linux-headers-generic-hwe-18.04') ) {
				$wasInstalled = 0;
				$packageLinuxHeadersGenericHwe1804 = installPackage('linux-headers-generic-hwe-18.04');
			} else {
				$packageLinuxHeadersGenericHwe1804 = 1;
			}
			if( ! isPackageInstalled('linux-signed-generic-hwe-18.04') ) {
				$wasInstalled = 0;
				$packageLinuxSignedGenericHwe1804 = installPackage('linux-signed-generic-hwe-18.04');
			} else {
				$packageLinuxSignedGenericHwe1804 = 1;
			}
	
			if( $packageLinuxGenericHwe1804 && $packageLinuxImageGenericHwe1804 && $packageLinuxHeadersGenericHwe1804 && $packageLinuxSignedGenericHwe1804 ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed");
					addToConfiguredModules($module, "nothingToDo");
				} else {
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		
		}
		if ($distributionVersion =~ /20.04/) {
			my $noIncompatibleKernel = 1;
			if( isPackageInstalled('linux-image-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-image-oem-20.04'); 
			}
			if( isPackageInstalled('linux-headers-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-oem-20.04');
			}
			if( isPackageInstalled('linux-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-headers-oem-20.04');
			}

			# check if the package is already installed
			if( ! isPackageInstalled('linux-generic-hwe-20.04') ) {
				$wasInstalled = 0;
				$packageLinuxOem2004 = installPackage('linux-generic-hwe-20.04');
			} else {
				$packageLinuxOem2004 = 1;
			}
			if( ! isPackageInstalled('linux-firmware') ) {
				$wasInstalled = 0;
				$packageLinuxFirmware = installPackage('linux-firmware');
			} else {
				$packageLinuxFirmware = 1;
			}
			if( ! isPackageInstalled('intel-microcode') ) {
				$wasInstalled = 0;
				$packageIntelMicrocode = installPackage('intel-microcode');
			} else {
				$packageIntelMicrocode = 1;
			}

			if( $wasInstalled && $noIncompatibleKernel ) {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} elsif ( $packageLinuxOem2004 && $packageLinuxFirmware && $packageIntelMicrocode && !isPackageInstalled('linux-image-oem-20.04') && !isPackageInstalled('linux-headers-oem-20.04') && !isPackageInstalled('linux-oem-20.04') ) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		}
	}
	if ($action eq 'upgrade') {
		if ($distributionVersion =~ /20.04/) {
			my $noIncompatibleKernel = 1;
			if( isPackageInstalled('linux-image-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-image-oem-20.04'); 
			}
			if( isPackageInstalled('linux-headers-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-oem-20.04');
			}
			if( isPackageInstalled('linux-oem-20.04') ) {
				$noIncompatibleKernel = 0;
				deinstallPackage('linux-headers-oem-20.04');
			}

			# check if the package is already installed
			if( ! isPackageInstalled('linux-generic-hwe-20.04') ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageLinuxOem2004 = installPackage('linux-generic-hwe-20.04');
			} else {
				$packageLinuxOem2004 = 1;
			}
			if( ! isPackageInstalled('linux-firmware') ) {
				$wasInstalled = 0;
				$packageLinuxFirmware = installPackage('linux-firmware');
			} else {
				$packageLinuxFirmware = 1;
			}
			if( ! isPackageInstalled('intel-microcode') ) {
				$wasInstalled = 0;
				$packageIntelMicrocode = installPackage('intel-microcode');
			} else {
				$packageIntelMicrocode = 1;
			}

			if( $wasInstalled && $noIncompatibleKernel ) {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} elsif ( $packageLinuxOem2004 && $packageLinuxFirmware && $packageIntelMicrocode && !isPackageInstalled('linux-image-oem-20.04') && !isPackageInstalled('linux-headers-oem-20.04') && !isPackageInstalled('linux-oem-20.04') ) {
				addToConfiguredModules($module, "success");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# nvidiadriver
# installs TUXEDO approved nvidia drivers and removes all the other ones
#
sub nvidiadriver() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageNvidiaDriver460;
	my $packageMesaUtils;
	my $packageNvidiaPrime;
	my $packagePythonAppindicator;
	my $packagePythonCairo;
	my $packagePythonGtk2;
	my $oldDriversRemoved;
	if ($action eq 'install') {
		if ($distributionVersion =~ /18.04/) {
			# deinstall other nvidia drivers
			$oldDriversRemoved = deinstExcept('nvidia-driver-', 'nvidia-driver-460');

			# check if the package is already installed
			if( ! isPackageInstalled('nvidia-driver-460') ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver460 = installPackage('nvidia-driver-460');
			} else {
				$packageNvidiaDriver460 = 1;
			}
			if( ! isPackageInstalled('mesa-utils') ) {
				$wasInstalled = 0;
				$packageMesaUtils = installPackage('mesa-utils');
			} else {
				$packageMesaUtils = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}
			if( ! isPackageInstalled('python-appindicator') ) {
				$wasInstalled = 0;
				$packagePythonAppindicator = installPackage('python-appindicator');
			} else {
				$packagePythonAppindicator = 1;
			}
			if( ! isPackageInstalled('python-cairo') ) {
				$wasInstalled = 0;
				$packagePythonCairo = installPackage('python-cairo');
			} else {
				$packagePythonCairo = 1;
			}
			if( ! isPackageInstalled('python-gtk2') ) {
				$wasInstalled = 0;
				$packagePythonGtk2 = installPackage('python-gtk2');
			} else {
				$packagePythonGtk2 = 1;
			}
	
			if( $oldDriversRemoved && $packageNvidiaDriver460 && $packageMesaUtils && $packageNvidiaPrime && $packagePythonAppindicator && $packagePythonCairo && $packagePythonGtk2 ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed");
					addToConfiguredModules($module, "nothingToDo");
				} else {
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		
		}
		if ($distributionVersion =~ /20.04/) {
			# deinstall other nvidia drivers
			$oldDriversRemoved = deinstExcept('nvidia-driver-', 'nvidia-driver-460');

			# check if the package is already installed
			if( ! isPackageInstalled('nvidia-driver-460') ) {
				messageLongInstall();
				$wasInstalled = 0;
				$packageNvidiaDriver460 = installPackage('nvidia-driver-460');
			} else {
				$packageNvidiaDriver460 = 1;
			}
			if( ! isPackageInstalled('mesa-utils') ) {
				$wasInstalled = 0;
				$packageMesaUtils = installPackage('mesa-utils');
			} else {
				$packageMesaUtils = 1;
			}
			if( ! isPackageInstalled('nvidia-prime') ) {
				$wasInstalled = 0;
				$packageNvidiaPrime = installPackage('nvidia-prime');
			} else {
				$packageNvidiaPrime = 1;
			}
	
			if( $oldDriversRemoved && $packageNvidiaDriver460 && $packageMesaUtils && $packageNvidiaPrime ) {
				if ($wasInstalled) {
					printLog("$origConfModules{$module}{name} was already installed");
					addToConfiguredModules($module, "nothingToDo");
				} else {
					addToConfiguredModules($module, "success");
					$restartSystem = 1;
				}
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# cracklib-runtime
#
sub cracklibruntime() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Fixes AMD GPU frequency communication with display
#
sub amdgpudkms() {
	my $module = shift;
	my $action = shift;
	my $wasInstalled = 1;
	my $packageamdgpu_dkms_firmware;
	my $packageamdgpu_dkms;
	if ($action eq 'install') {
		# check if the package is already installed
		if( ! isPackageInstalled('amdgpu-dkms-firmware') ) {
			messageLongInstall();
			$wasInstalled = 0;
			$packageamdgpu_dkms_firmware = installPackage('amdgpu-dkms-firmware');
		} else {
			$packageamdgpu_dkms_firmware = 1;
		}
		if( ! isPackageInstalled('amdgpu-dkms') ) {
			messageLongInstall();
			$wasInstalled = 0;
			$packageamdgpu_dkms = installPackage('amdgpu-dkms');
		} else {
			$packageamdgpu_dkms = 1;
		}

		if( $packageamdgpu_dkms_firmware && $packageamdgpu_dkms ) {
			if ($wasInstalled) {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			} else {
				addToConfiguredModules($module, 'success');
			}
			$origConfModules{$module}{installed} = 'yes';
			$origConfModules{$module}{upgraded} = 'yes';
		} else {
			$origConfModules{$module}{installed} = 'failed';
			addToConfiguredModules($module, 'failed');
		}
	}
	if ($action eq 'upgrade') {
		printLog('upgrade not necessary for packages');
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Installs Linux device driver for several Realtek Ethernet controllers
#
sub r8168dkms() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Installs package tuxedo-oled-brt to control the brightness of OLED displays
# using xrandr and dbus
# The original program is from System76 https://github.com/pop-os/system76-oled
#
sub tuxedooledbrt() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# deactivates apport reporting
#
sub apportfix() {
	my $module = shift;
	my $action = shift;
	my $oldApportLine = 'default=1';
	my $newApportLine = 'default=0';
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");

		if (isLineInFile('/etc/default/apport', 'enabled=1')) {
			$retval = substituteLineInFile('/etc/default/apport', 'enabled=1', 'enabled=0');
			if ($retval == 1) {
				printLog('apport was disabled in /etc/default/apport');
				#`service apport stop`;
				#printLog("service apport stop returned: $?");
				#`systemctl disable apport.service`;
				#printLog("systemctl disable apport.service returned: $?");
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} elsif (isLineInFile('/etc/default/apport', 'enabled=0')) {
			printLog('apport was already disabled in /etc/default/apport');
			#`service apport stop`;
			#printLog("service apport stop returned: $?");
			#`systemctl disable apport.service`;
			#printLog("systemctl disable apport.service returned: $?");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			addToConfiguredModules($module, "success");
		} else {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		}
	}
	if ($action eq 'upgrade') {
		# not neccessary
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}




###############################################################################
# Installs Linux device driver for several Realtek Ethernet controllers
#
sub realtekr8125dkms() {
	my $module = shift;
	my $action = shift;
	if ($action eq 'install') {
		# check before if the package is already installed
		if (! isPackageInstalled($origConfModules{$module}{name})) {
			messageLongInstall();
			if (installPackage($origConfModules{$module}{name})) {
				$origConfModules{$module}{installed} = "yes";
				$origConfModules{$module}{upgraded} = "yes";
				addToConfiguredModules($module, "success");
				$restartSystem = 1;
			} else {
				$origConfModules{$module}{installed} = "failed";
				addToConfiguredModules($module, "failed");
			}
		} else {
			printLog("$origConfModules{$module}{name} was already installed");
			addToConfiguredModules($module, "nothingToDo");
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrade not necessary for packages");
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}



###############################################################################
# Fixes backlight issue with BOE Model 2423 Serial Number 0 displays on
# - GMxNGxx
#
sub amdgpubacklightauxoff() {
	my $module = shift;
	my $action = shift;
	my @kernel_parameters = ("amdgpu.backlight=0");
	my $retval;
	if ($action eq 'install') {
		printLog("applying $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;	
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'upgrade') {
		printLog("upgrading $origConfModules{$module}{name}");
		$retval = insertGrub($module, \@kernel_parameters);
		if ($retval < 0) {
			$origConfModules{$module}{installed} = "failed";
			addToConfiguredModules($module, "failed");
		} else {
			$origConfModules{$module}{installed} = "yes";
			$origConfModules{$module}{upgraded} = "yes";
			if ($retval > 0) {
				addToConfiguredModules($module, "success");
				$postConfProgram{updateGrub}{trigger} = 1;
			} else {
				printLog("$origConfModules{$module}{name} was already installed");
				addToConfiguredModules($module, "nothingToDo");
			}
		}
	}
	if ($action eq 'remove') {
		# not implemented yet
	}
}





###############################################################################
###############################################################################
# subs for corefix md5 tests
#

###############################################################################
# returns 1 if md5 file loaded correctly
# returns 0 if md5 file failed to load
#
sub loadMD5Store {
	my $md5Line;
	if (open(FH, "<", $md5Store)) {
		while ($md5Line = <FH>) {
			chop($md5Line);
			my ($key, $val) = split /:/, $md5Line;
			$initrdHashSaved{$key} = $val;
		}
		close FH;
		return (1);
	} else {
		printLog("no readable md5sum file available");
		return (0);
	}
}

sub readInitrdMD5Files {
	my $initrdData;
	my $md5sum;
	if (opendir(BOOTDIR, '/boot')) {
		while (readdir BOOTDIR) {
			if ($_ =~ /initrd\.img/) {
				local $/ = undef;
				if (open( INITRDFILE, "/boot/$_" ) ) {
					binmode(INITRDFILE);
					$initrdData = <INITRDFILE>;
					$md5sum = md5_hex($initrdData);
					$initrdHashFiles{$_} = $md5sum;
					close(INITRDFILE);
				}
			}
		}
		close BOOTDIR;
	}
}

sub writeMD5Store {
	if (open(FH, ">", $md5Store)) {
		foreach my $key (keys %initrdHashFiles ) {
			print FH "$key:$initrdHashFiles{$key}\n";
		}
		close(FH);
	} else {
		printLog("could not open $md5Store");
	}
}

###############################################################################
# returns 1 if found non equal or missing value between value in files and
# saved values
# returns 0 if all values are the same
# returns 1 if something is different
#
sub newInitrdFiles {
	if (loadMD5Store()) {
		readInitrdMD5Files();
		foreach my $key (keys %initrdHashFiles) {
			if (!(exists $initrdHashSaved{$key}) || ($initrdHashFiles{$key} ne $initrdHashSaved{$key})) {
				return (1);
			}
		}
	} else {
		return (1);
	}
	return (0);
}




###############################################################################
# subs for tuxedorepos & tuxedomirrors
#

###############################################################################
# Adds the TUXEDO repos to the system with public key
# returns 2 if successful and changes to repos were made
# returns 1 if successful and no changes to repos
# returns 0 if failed
#
sub createRepos {
	my %repos = %{$_[0]};
	my %repoHash;
	my $compDistVer = $distribution.' '.$distributionVersion;
	my $key;
	my $DH;
	my $sourceline;
	my $modified = 0;
	my $sourcesListDir = '/etc/apt/';
	my $sourcesListDirD = '/etc/apt/sources.list.d/';
	my $sourcesFileName = $sourcesListDir.'sources.list';
	if (!-d $sourcesListDir) {
		printLog("no $sourcesListDir found (something's really wrong)", 'TL');
		# no apt directory, somethings fishy
		return (0);
	}
	if (!-d $sourcesListDirD) {
		printLog("no $sourcesListDirD found, creating one", 'TL');
		mkdir($sourcesListDirD);
	}

	if (-e $sourcesFileName) {
		$repoHash{$sourcesFileName} = [readFileReturnLines($sourcesFileName)];
	}

	# read content from all files *.list into hash
	if (opendir($DH,$sourcesListDirD)) {
		while (readdir $DH) {
			if ( $_ =~ /.*\.list$/ ) {
				$sourcesFileName = $sourcesListDirD.$_;
				$repoHash{$sourcesFileName} = [readFileReturnLines($sourcesFileName)];
			}
		}
		closedir($DH);
	}

	my $firstEntry;
	my $sourcesListBackedup = 0;
	foreach $key (keys %{ $repos{$compDistVer} }) {
		# each line
		if ($key ne 'name') {
			$firstEntry = 1;
			foreach (@{ $repos{$compDistVer}{$key}{content} }) {
				if (!isLinePresent($_, %repoHash)) {
					# make backup if file exists and is first entry into file
					if ( (-s $repos{$compDistVer}{$key}{filename}) && ($firstEntry == 1) ) {
						backupFile($repos{$compDistVer}{$key}{filename});
						$firstEntry = 0;
						if ($repos{$compDistVer}{$key}{filename} eq '/etc/apt/sources.list' ) {
							$sourcesListBackedup = 1;
						}
					}
					# create file + line
					if (! -e $repos{$compDistVer}{$key}{filename}) {
						createFile($repos{$compDistVer}{$key}{filename}, "# Added by TUXEDO Tomte\n$_\n");
						printLog("new file: $repos{$compDistVer}{$key}{filename}");
						printLog("added: $_");
						$firstEntry = 0;
						$modified = 1;
					# or append line
					} else {
						appendFile($repos{$compDistVer}{$key}{filename}, "\n# Added by TUXEDO Tomte\n$_\n");
						printLog("append file: $repos{$compDistVer}{$key}{filename}");
						printLog("added: $_");
						$modified = 1;
					}
				}
			}
		}
	}
	return ($modified+1);
}



###############################################################################
# add the repo key for TUXEDO repos
#
sub addRepoKey {
	my $output;
	my $retval;
	checkNetwork();
	$output = `apt-key adv --fetch-keys https://deb.tuxedocomputers.com/0x54840598.pub.asc 2>&1`;
	$retval = $?;
	if ($retval != 0) {
		printLog("error when apt-key adv");
		printLog("return value: $retval");
		printLog("could not add pub key for TUXEDO repos");
		return (0);
	}
	return (1);
}



###############################################################################
# comment out anything else on sources.list which has
# deb mirrorurl and not tuxedocomputers
# returns 0 if nothing was changed
# returns 1 if modifications were made
#
sub cleanSourcesList {
	my $FHsource;
	my @sourcelines;
	my $sourceline;
	my $sourcesListDir = '/etc/apt/';
	my $modified = 0;
	# read all the lines
	if (open $FHsource, "<", $sourcesListDir."sources.list") {
		chomp(@sourcelines = <$FHsource>);
		close $FHsource;
		# open for writing
		if (open $FHsource, ">", $sourcesListDir."sources.list") {
			foreach $sourceline (@sourcelines) {
				if (setComment(\$sourceline)) {
					$modified = 1;
				}
				# no backup for the file as it only comments out lines
				print $FHsource "$sourceline\n";
			}
			close $FHsource;
		}
	}
	return ($modified);
}


###############################################################################
# decides whether the line has to be commented out or not
# returns 0 if nothing changed
# returns 1 if commented out
# modifies the string given to the subroutine
#
sub setComment {
	my $repoline = shift;
	my $tmpline = $$repoline;
	my $FH;
	my @repolines;
	my $compDistVers = "$distribution $distributionVersion";
	my $regEx = '^deb.*\.ubuntu\.com\/ubuntu.* '.$tuxedo_mirrors{$compDistVers}{name}.'.*$';
	if (open $FH, '<', $reposList ) {
		chomp(@repolines = <$FH>);
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("could not open repository mirrors list at $reposList", 'TL');
		return (0);
	}
	if ( $$repoline =~ /^deb .*$tuxedo_mirrors{$compDistVers}{name}.*/ ) {
		# this is a repo line
		# if line matches some official debian country mirror & not tuxedo
		# delete old mirrors.tuxedocomputers.com urls
		if ( (($$repoline =~ m/$regEx/) && !($$repoline =~ m/packages\.tuxedocomputers.*main restricted universe multiverse/)) || $$repoline =~ m/^deb http:\/\/mirrors\.tuxedocomputers\.com\// ) {
			$$repoline = "\n#### commented out by TUXEDO Tomte\n"."# $$repoline";
			printLog("commented out: $$repoline");
			return (1);
		}
		# check for repos in comprehensive mirror list
		foreach (@repolines) {
			if ( $$repoline =~ /$_/ ) {
				# repo matches
				$$repoline = "\n#### commented out by TUXEDO Tomte\n"."# $$repoline";
				printLog("commented out: $$repoline");
				return (1);
			}
		}
	} else {
		# nothing has to be done
		return (0);
	}
}



###############################################################################
# package handling
#

###############################################################################
# Deinstalls all packages beginning with a given string except the one given as
# second parameter
# returns 0 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 1 if everything was ok, even if no packages were found
#
sub deinstExcept {
	my $deinst = shift;
	my $except = shift;
	my $searchCmd = "dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' $deinst*"." 2>&1";
	my $retString = `$searchCmd`;
	my $retValue = $?/256;
	my $deinstCmd;
	if ($retValue != 0) {
		if ($retValue == 1) {
			printLog("no packages found matching search string to deinstall packages: $deinst with except pattern: $except");
			return (1);
		}
		printLog('something went wrong while searching for packages');
		return (0);
	}
	my %retHash = $retString =~ /(\S+)\s*(\S+)/g;

	if ($FAI) {
		$deinstCmd = 'apt-get -yq remove';
	} else {
		$deinstCmd = 'pkcon -yp remove';
	}
	my $deinstCounter = 0;

	foreach my $deinstKey (keys %retHash) {
		if (($retHash{$deinstKey} =~ /i./) && !($deinstKey =~ $except)) {
			$deinstCounter++;
			$deinstCmd = $deinstCmd.' '.$deinstKey;
		}
	}
	if ($deinstCounter != 0) {
		printLog("deinstalling: $deinstCmd");
		$deinstCmd = $deinstCmd.' >/dev/null 2>&1';
		if (system($deinstCmd)) {
			$retValue = $?/256;
			printLog("failed to deinstall packages, retvalue: $retValue");
			return (0);
		} else {
			printLog('deinstallation of packages successful');
			return (1);
		}
	} else {
		printLog('nothing to deinstall');
		return (1);
	}
}



###############################################################################
# Deinstalls all packages beginning with a given string
# uses '*' at end of package name to be searched
# returns 1 if the search for the packages failed or if the deinstallation was
# unsuccessful
# returns 0 if everything was ok, even if no packages were found
#
sub deinstallPackage {
	my $deinst = shift;
	my $searchCmd = "dpkg-query -W -f=\'\${Package} \${db:Status-Abbrev}\n\' $deinst*"." 2>&1";
	my $retString = `$searchCmd`;
	my $retValue = $?/256;
	if ($retValue != 0) {
		if ($retValue == 1) {
			printLog("no packages found matching search string to deinstall packages: $deinst");
			return (0);
		}
		printLog("something went wrong while searching for packages: $deinst");
		return (1);
	}
	my %retHash = $retString =~ /(\S+)\s*(\S+)/g;

	my $pkconDeinst = 'pkcon -yp remove';
	my $deinstCounter = 0;

	foreach my $deinstKey (keys %retHash) {
		if ($retHash{$deinstKey} =~ /i./) {
			$deinstCounter++;
			$pkconDeinst = $pkconDeinst.' '.$deinstKey;
		}
	}
	if ($deinstCounter != 0) {
		printLog("deinstalling: $pkconDeinst");
		$pkconDeinst = $pkconDeinst.' >/dev/null 2>&1';
		if (system($pkconDeinst)) {
			$retValue = $?/256;
			printLog("failed to deinstall packages, retvalue: $retValue");
			return (1);
		} else {
			printLog('deinstallation of packages successful');
			return (0);
		}
	} else {
		printLog('nothing to deinstall');
		return (0);
	}
}



###############################################################################
# Checks if the package is installed on the system
# return 1 if yes
# return 0 if no
#
sub isPackageInstalled {
	my $package = shift;
	my $cmd = 'dpkg-query -W -f=\'${status}\' '.$package.' 2>&1';
	my $retString = `$cmd`;
	my $retValue = $?/256;
	if ($retString =~ m/install ok installed/) {
		printLog("package $package is installed");
		return (1);
	} else {
		printLog("package $package is not installed");
		return (0);
	}
}



###############################################################################
# installs a package by pkcon or apt-get
# returns 1 if successful
# returns 0 if package was not installed
#
sub installPackage {
	my $packageName = shift;
	my $retval;
	printLog("install package $packageName");
	if ($FAI) {
		system("apt-get -qy install $packageName >/dev/null 2>&1");
		$retval = isPackageInstalled($packageName);
	} else {
		checkNetwork();
		system("pkcon -yp install $packageName >/dev/null 2>&1");
		$retval = isPackageInstalled($packageName);
		if ($retval == 0) {
			printLog("failed to install $packageName");
			printLog("will try again later");
			startTomteDelayed();
		}
	}
	return $retval;
}


###############################################################################
# creates file with content
# 
sub createFile {
	my $fileName = shift;
	my $fileText = shift;
	my $FH;
	if (-e $fileName) {
		backupFile($fileName);
	}
	if (open $FH, ">",$fileName) {
		print $FH "$fileText";
		close $FH;
		return (1);
	} else {
		printLog("Err: $!");
		printLog("can't open $fileName for writing", 'TL');
		return (0);
	}
}



###############################################################################
# appends text to the file
# 
sub appendFile {
	my $fileName = shift;
	my $fileText = shift;
	my $FH;
	if (open $FH, ">>",$fileName) {
		print $FH "$fileText";
		close $FH;
		return (1);
	} else {
		printLog("Err: $!");
		printLog("can't open $fileName for writing", 'TL');
		return (0);
	}
}



###############################################################################
# backups file with timestamp
# 
sub backupFile {
	my $fileName = shift;
	my $backupFile = $fileName.'_'.getBackupFileTime().'.bak';
	if (copy($fileName, $backupFile)) {
		printLog("created backup for $fileName", 'TL');
		return (1);
	} else {
		printLog("Err: $!");
		printLog("can't create backup file for $fileName", 'TL');
		return (0);
	}
}



###############################################################################
# checks if the line exists in the file
# 
sub isLinePresent {
	my $line = shift;
	my (%hash) = @_;
	my $filenameKey;
	foreach $filenameKey (keys %hash) {
		foreach (@{ $hash{$filenameKey} }) {
			if ($line eq $_) {
				return (1);
			}
		}
	}
	return (0);
}



###############################################################################
# substituteFileInLine('filename', 'string1', 'string2')
# substitutes a line in 'file' as 'string1' with 'string2
# returns 0 if line is already there
# returns 1 if successful (line was modified)
# returns -1 if something went wrong
# 
sub substituteLineInFile {
	my $filename = shift;
	my $origLine = shift;
	my $substLine = shift;
	my @fileLines;
	my $FH;

	if ( open $FH, "<", $filename) {
		while (<$FH>) {
			push (@fileLines, $_);
		}
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("no $filename present or unable to open the file for reading");
		return (-1);
	}

	foreach( @fileLines ) {
		if ( $_ =~ /^$origLine$/ ) {
			$_ = "$substLine\n";
		}
	}
	if ( open $FH, ">", $filename ) {
		print $FH @fileLines;
		close ($FH);
		return (1);
    } else {
		printLog("Err: $!");
		printLog("no $filename present or unable to open the file for writing");
		return (-1);
    }

	return (0);
}



###############################################################################
# isLineInFile('filename', 'string')
# matches a line with the 'string' and returns
# 1 if found
# 0 if not found or failed to open file
#
sub isLineInFile {
	my $filename = shift;
	my $match = shift;
	if ( open FH, '<', $filename ) {
		while( <FH> ) {
			if ( $_ =~ /^$match$/) {
				return (1);
			}
		}
	} else {
		printLog("can't open file $filename");
	}
	return (0);
}



###############################################################################
# returns 1 if active interface found
# returns 0 if none found
sub networkStatus {
	my $dirHandle;
	my $interfacesDir = '/sys/class/net';
	if ( !opendir ($dirHandle, $interfacesDir)) {
		printLog("unable to open $interfacesDir: $!");
		return (0);
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' && $_ ne 'lo' } readdir($dirHandle);
	if (scalar(@FILES) < 1) { return (0); }
	foreach my $file (@FILES) {
		if (readFileReturnLine("$interfacesDir/$file/operstate") eq 'up' ) {
			return (1);
		}
	}
	return (0);
}



###############################################################################
# waitForNetwork('number of tries', 'wait seconds')
# polls for a network interface for status up
# tries 'number of tries' times and waits in between for 'wait seconds' seconds
# returns 1 if network is active
# returns 0 if network not active
sub waitForNetwork {
	my $tries = shift;
	my $wait = shift;
	for ( my $i=1; $i<=$tries; $i++ ) {
		if (networkStatus()) { return (1); }
		printLog("waiting for network: $i of $tries");
		sleep ($wait);
	}
	return (0);
}




###############################################################################
# waitForNetwork('number of tries', 'wait seconds')
sub checkNetwork {
	if ( (! $FAI) && (! $networkSearchDone) ) {
		if (waitForNetwork(10, 10)) {
			$networkSearchDone = 1;
			printLog('found network !');
		} else {
			$networkSearchDone = 1;
			printLog('no network found !! some fixes might not be applied correctly');
		}
	}
}




###############################################################################
# inserts array values as kernel parameters if not present
# example: my $retval = insertGrub(\@kernel_parameters);
# returns number of inserted parameters
# return value of -1 means it failed
#
sub insertGrub {
    my $grubFH;
    my @grub_lines;
	my $module = shift;
    my $parameters = shift;
    my $parameter;
	my $inserted = 0;

    if ( open $grubFH, "<", $grubFile) {
		while (<$grubFH>) {
	    	push (@grub_lines, $_);
		}
		close $grubFH;
    } else {
		printLog("Err: $!");
		printLog("no $grubFile present or unable to open the file for reading");
		return (-1);
    }

    foreach( @grub_lines ) {
		# find the correct line
		if ( $_ =~ /^GRUB_CMDLINE_LINUX_DEFAULT="/ ) {
			foreach $parameter ( @{$parameters} ) {
				if (insertGrubParameter(\$_, \$parameter)) {
					++$inserted;
				}
			}
		}
    }

	# write the changes into grub config
    if ( open $grubFH, ">", $grubFile ) {
		print $grubFH @grub_lines;
		close ($grubFH);
    } else {
		printLog("Err: $!");
		printLog("no $grubFile present or unable to open the file for writing");
		return (-1);
    }
    return $inserted;
}


###############################################################################
# inserts a parameter into a grub line
# if the parameter is not present yet
# returns 1 if parameter inserted
# returns 0 if parameter already present
#
sub insertGrubParameter {
	my ($line, $parameter) = @_;

	if ($$line =~ /$$parameter/) {
		return (0);
	}
	if ($$line =~ /""/) {
		$$line =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1$$parameter"\n/;
		printLog("inserted '$$parameter' into grub line");
		return (1);
	} else {
		$$line =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1 $$parameter"\n/;
		printLog("inserted '$$parameter' into grub line");
		return (1);
	}
}




###############################################################################
# send message to desktop
# returns 1 if message was sent
# returns 0 if message could not be delivered for any reason
# icon:
# 	dialog-warning
# 	dialog-error
# 	dialog-information
# 	freedesktop.org
# urgency:
# 	0 : Low
# 	1 : Normal
# 	2 : Critical
#
sub messageDesktop {
	my $summary = shift;
	my $body = shift;
	my $urgency = shift;
	my $icon = shift;

	my $mUsername = '';
	my $mPid = '';
	my $mLine = '';
	my @whoLines = `who -u`;

	foreach $mLine (@whoLines) {
		if ($mLine =~ /\(:\d+\)/) {
			$mLine =~ /^(\w*).*\s(\d*)\s.*/;
			$mUsername = $1;
			$mPid = $2;
		}
	}
	if (($mUsername eq '') || ($mPid eq '')) {
		printLog('No display for message output found');
		return (0);
	}

	my $dbusAddress;

	if ( open(FH, "<", "/proc/$mPid/environ") ) {
		$dbusAddress = do { local $/; <FH> };
		close FH;
	} else {
		printLog('No display for message output found');
		return (0);
	}
	
	$dbusAddress =~ /.*?(DBUS_SESSION_BUS_ADDRESS=unix:path=\/run\/user\/\d*\/bus).*/;
	$dbusAddress = $1;
	if ($dbusAddress eq '') {
		printLog('No display for message output found');
		return (0);
	}

	my $mCmd = "sudo -u $mUsername $dbusAddress gdbus call --session --dest=org.freedesktop.Notifications --object-path=/org/freedesktop/Notifications --method=org.freedesktop.Notifications.Notify \"TUXEDO Tomte\" $sessionID \"$icon\" '$summary' '$body' '[]' '{\"urgency\": <$urgency>, \"desktop-entry\": <\"tuxedo-control-center\">}' 5000";

	`$mCmd`;

	if ($? != 0) {
		printLog('No display for message output found');
		return (0);
	}
	return (1);
}



###############################################################################
# prints a message on display informing about an expected long install time
# does nothing if the message was already sent
#
sub messageLongInstall {
	if ($longInstall == 0) {
		if (messageDesktop('TUXEDO Tomte is installing fixes','Please do not restart or shutdown the system.', 2, 'dialog-warning')) {
			$longInstall = 1;
		}
	}
}


###############################################################################
# initialize logFile
# create one if not existing already
# exits program if logfile can not be created
#
sub initLogging {
	my %options;
	@options{"list", "configure", "reconfigure", "remove", "block", "unblock", "update"} = ();
	# do not log if no arguments
	if ($argValue{command} eq '') {
		return;
	}
	# do not log if false arguments
	if (! (exists $options{$argValue{command}})) {
		return;
	}

	# check if root permissions available
	if (! isRoot()) {
		return;
	}

	my $timestamp;
	# create logDir if it does not exist
	unless ( -d $logDir ) {
		mkdir($logDir, 0755);
		unless ( -d $logDir ) {
			$noLogFile = 1;
			print "Could not create $logDir\n";
			return;
		}
	}
	# check for logfile
	if ( -f $logFile ) {
		# append if logFile exists
		if ( open $LOGFILE, '>>'.$logFile )
		{
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog('starting Tomte');
			return;
		} else {
			printLog("Err: $!");
			$noLogFile =1;
			print "Could not open logFile $logFile\n$!\n";
			exit (0);
		}
	} else {
		# create a new logFile
		if ( open $LOGFILE, '>'.$logFile ) {
			$noLogFile = 0;
			$timestamp = getLoggingTime();
			close $LOGFILE;
			printLog('starting Tomte');
			return;
		} else {
			printLog("Err: $!");
			$noLogFile =1;
			print "Could not create logFile $logFile\n";
			exit (0);
		}
	}
}



###############################################################################
#
sub getLoggingTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d %02d:%02d:%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
#
sub getBackupFileTime {
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $nice_timestamp = sprintf ( "%04d%02d%02d%02d%02d%02d",
									$year+1900,$mon+1,$mday,$hour,$min,$sec);
	return $nice_timestamp;
}



###############################################################################
# prints into logFile or to terminal
# printLog('message', 'tl')
# it assumes 'l' or 'L' if 't', 'T', 'L' or 'l' are ommited
#
sub printLog {
	my $message = shift;
	my ($type) = @_;
	if (!defined($type)) {
		$type = 'l';
	}
	if ($FAI || ($type =~ /t/i)) {
		print "$message\n";
	}
	if ((!$noLogFile) && (!$FAI && ($type =~ /l/i))) {
		if (open $LOGFILE, '>>'.$logFile) {
			my $timestamp = getLoggingTime();
			print $LOGFILE "$timestamp $message\n";
			close $LOGFILE;
		}
	}
}


###############################################################################
# fills global variable %localConfModules with data from $configFile
# if there is no configFile then it is left empty
# returns '0' if configfile can not be read, else returns '1'
#
sub readConfigFile {
	my %comp;
	my $FH;
	my $shortname;
	if ( open $FH, '<', $configFile ) {
		while ( my $line=<$FH> ) {
			chomp $line;
			# ignore comments
			if ($line =~ /^#/) {
				next;
			}
			# ignore empty lines
			if ($line =~ /^(\s)*$/) {
				next;
			}
			# check data format
			if (validConfigLine($line)) {
				my ($name, @cols) = split /\s+/, $line;
				# check if module name exists in orig and return shortname
				$shortname = validModuleName($name);
				if ($shortname ne '') {
					# @comp values have to be same as in writeConfigFile
					@comp{qw(name version installed blocked required hwid)} = ($name, @cols);
					$localConfModules{$shortname} = { %comp };
					# convert to numbers
					$localConfModules{$shortname}{version} = $localConfModules{$shortname}{version} * 1;
					$localConfModules{$shortname}{hwid} = $localConfModules{$shortname}{hwid} * 1;
				} else {
					printLog("module: $name does not exist");
				}
			} else {
				printLog("invalid line in $configFile");
			}
		}
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("could not open configFile: $configFile $!", 'TL');
		return (0);
	}
	return (1);
}


###############################################################################
# checks if the line has valid values
# return 0 if invalid, 1 if valid
#
sub validConfigLine {
	my $line = shift;
	if ($line =~ /^[a-zA-Z0-9\-]+\s[a-zA-Z0-9\-]\s(yes|no|failed)\s(yes|no)\s(yes|no|prerequisite)\s[a-zA-Z0-9\-]\s*$/) {
		return (1);
	} else {
		printLog("found invalid configuration line in $configFile:\n$line");
		return (0);
	}
}



###############################################################################
# overwrites $configFile with data from $origConfModules if it does not exist
#
sub writeConfigFile {
	my $FH;
	my $installed;
	my $version;
	my $hwid;
	if ( open $FH, '>', $configFile ) {
		printLog("writing configfile");
		print $FH "# name version installed blocked required hwid\n";
		foreach my $name (sort keys %origConfModules) {
			# values have to be same as in readConfigFile
			if ($origConfModules{$name}{upgrade} eq 'yes') {
				# upgrade available
				if ($origConfModules{$name}{upgraded} eq 'yes') {
					# upgrade was executed
					$version = $origConfModules{$name}{version};
					$hwid = $origConfModules{$name}{hwid};
					$installed = $origConfModules{$name}{installed};
				} else {
					# upgrade was not executed
					if ( $origConfModules{$name}{installed} eq 'yes' ) {
						$version = $localConfModules{$name}{version};
						$hwid = $localConfModules{$name}{hwid};
						$installed = $localConfModules{$name}{installed};
					} else {
						$version = $origConfModules{$name}{version};
						$hwid = $origConfModules{$name}{hwid};
						$installed = $localConfModules{$name}{installed};
					}
				}
			} else {
				# no upgrade available
				$version = $origConfModules{$name}{version};
				$hwid = $origConfModules{$name}{hwid};
				$installed = $origConfModules{$name}{installed};
			}
			print $FH "$origConfModules{$name}{name} ".
					"$version ".
					"$installed ".
					"$origConfModules{$name}{blocked} ".
					"$origConfModules{$name}{required} ".
					"$hwid\n";
		}
		close $FH;
	} else {
		printLog("Err: $!");
		printLog("can't write to configfile $configFile $!", 'TL');
		exit (0);
	}
}


###############################################################################
# check if config file and directory exists
# loads the config or if non existent
# creates a new directory and configfile
#
sub initConfigFile {
	# create configDir if it does not exist
	unless ( -d $configDir ) {
		mkdir($configDir, 0755);
		unless ( -d $configDir ) {
			$noConfigFile = 1;
			printLog("could not create $configDir", 'TL');
			exit (0);
		}
	}
	# read config file
	if ( -f $configFile ) {
		$noConfigFile = 0;
		readConfigFile();
		return;
	} else {
		# create a new configFile
		printLog("no configfile present ... creating one", 'TL');
		writeConfigFile();
		return;
	}
}


###############################################################################
# searches the sysfs subdirectory for active monitor entries
# and returns them as an array
#
sub findActiveEDIDs {
	my $cards_dir = '/sys/class/drm';
	my $dir_handle;
	my @edidfile;
	my $enabledFileContent;
	my $statusFileContent;

	my $edidTrigger = 0;

	if ( !opendir ($dir_handle, $cards_dir)) {
		printLog("Err: $!");
		printLog("unable to open $cards_dir: $!");
		return @edidfile;
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' } readdir($dir_handle);
	foreach my $file (@FILES) {
		my $path = "$cards_dir/$file";
		if ( -d $path ) {
			my $enabledFile = "$path/enabled";
			if ( -e $enabledFile ) {
				open(FILE, $enabledFile);
				$enabledFileContent = <FILE>;
				close(FILE);
				if ($enabledFileContent =~ /enabled/) {
					my $statusFile = "$path/status";
					if ( -e $statusFile ) {
						open(FILE2, $statusFile);
						$statusFileContent = <FILE2>;
						if ($statusFileContent =~ /connected/) {
							push @edidfile, "$path/edid";
							$edidTrigger = 1;
						}
					}
				}
			}
		}
	}
	if (! $edidTrigger ) {
		printLog('no enabled and active edid files found!');
	}
	return @edidfile;
}


###############################################################################
# gets valid edid files
# converts edid data into an array of hash references to origConfModules
#
sub getEDIDData {
	my @edidFiles = findActiveEDIDs();
	my @edidRefs;
	my @edidInfo;
	my $FH;
	my $fileContent;
	foreach ( @edidFiles ) {
		if ( open $FH, '<', $_ ) {
			$fileContent = do { local $/; <$FH> };
			close $FH;
			push @edidRefs, parse_edid($fileContent);
		} else {
			printLog("Err: $!");
			printLog("could not open file $_ $!");
		}
	}
	# returns array of hash references to module
	return @edidRefs;
}



###############################################################################
# returns 1 if the display described by a string is connected, otherwise 0
# the requesting string is build by appending the following data as returned by
# edid-decode
# manufacturer_name Model product_code Serial Number serial_number
# the values from manufacturer_name, product_code and serial_number are
# extracted by Parse::EDID
#
sub isDisplayPresent {
	my $edidSearchString = shift;
	my @edidRefs = getEDIDData();
	my $edidInfo;
	foreach my $edidData (@edidRefs) {
		$edidInfo = $$edidData{manufacturer_name}." Model ".$$edidData{product_code}." Serial Number ".$$edidData{serial_number};
		if ($edidInfo =~ /$edidSearchString/) {
			return (1);
		}
	}
	printLog("edid string not found");
	return (0);
}




###############################################################################
# print status from all modules in a nice formated output
# uses the data from the local configuration file if available
# else it checks the hardware
#
# used pattern:
# installed and new module version equal (no update)
# installed	req. old	req. new	notes
# no		no			no			ign
# yes		no			no			installed but not required!
# no		yes			no			ign
# yes		yes			no			ign
# no		no			yes			ign
# yes		no			yes			ign
# no		yes			yes			not inst. but required
# yes		yes			yes			inst. and req.
#
# installed and new module version not equal (update?)
# to be done in next version
#
sub listStatus {
	my @arr = ( ['Name', 'Version', 'Installed', 'Blocked', 'Required'] );
	my $module;
	my $noneRequired = 1;
	my $printIt = 0;
	my $upgradeAvailable = '';

	foreach $module (sort keys %localConfModules) {
		if($origConfModules{$module}{upgrade} eq 'yes') {
			$upgradeAvailable = ' - upgrade available';
		}
		if (($localConfModules{$module}{installed} eq 'yes') &&
		($localConfModules{$module}{required} eq 'no') &&
		($origConfModules{$module}{required} eq 'no')) {
			# module is installed but should not be
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}"]);
		}
		if (($localConfModules{$module}{required} eq 'yes') ||
			($localConfModules{$module}{required} eq 'prerequisite')) {
			$noneRequired = 0;
			$printIt = 1;
			push(@arr,
				["$localConfModules{$module}{name}",
				"$localConfModules{$module}{version}",
				"$localConfModules{$module}{installed}",
				"$localConfModules{$module}{blocked}",
				"$localConfModules{$module}{required}$upgradeAvailable"]);
		}
	}
	if ($printIt) {
		print "Only showing fixes that are available for this hardware\n";
		for my $row (@arr) {
			format STDOUT =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< @<<<<<<< @<<<<<<<<< @<<<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<
			@$row
.
			write;
		}
	}
	if ($noneRequired) {
		print "No fixes available for this system\n";
	}
}


###############################################################################
# copies values from local configuration module into new configuration module
# copies always 'blocked'
#
sub transferConfigValues {
	my $name;
	foreach $name (sort keys %localConfModules) {
		# always copy blocked status
		$origConfModules{$name}{blocked} = $localConfModules{$name}{blocked};
		if (newVersion($name) or newHwid($name)) {
			# new version or new hwid => upgrade necessary
			$origConfModules{$name}{upgrade} = 'yes';
			$origConfModules{$name}{upgraded} = 'no';
		} else {
			$origConfModules{$name}{installed} = $localConfModules{$name}{installed};
			$origConfModules{$name}{upgrade} = 'no';
			$origConfModules{$name}{upgraded} = 'no';
		}
	}
}



###############################################################################
# returns 0 if no new version
# returns 1 if new version
sub newVersion {
	my $module = shift;
	if ($localConfModules{$module}{version} < $origConfModules{$module}{version}) {
		return (1);
	} else {
		return (0);
	}
}


###############################################################################
# returns 0 if no new hwid
# returns 1 if new hwid
sub newHwid {
	my $module = shift;
	if ($localConfModules{$module}{hwid} < $origConfModules{$module}{hwid}) {
		return (1);
	} else {
		return (0);
	}
}



###############################################################################
# adds module hash to list of configured modules with status
#
sub addToConfiguredModules {
	my $module = shift;
	my $status = shift;
	$configuredModules{$module} = $status;
}



###############################################################################
# parses sub name from %origConfModules list from given module parameter name
# returns the name of the module vector of found
# returns an empty string if not found
#
sub getSubName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if ( $moduleName eq $origConfModules{$module}{name} ) {
			return $module;
		}
	}
	# return empty string if module is not found
	return "";
}


###############################################################################
# returns the shortname of module if the name is a valid module name
# returns '' if not
#
sub validModuleName {
	my $moduleName = shift;
	my $module;
	foreach $module ( keys %origConfModules ) {
		if (defined $origConfModules{$module}{name}) {
			if ($origConfModules{$module}{name} eq $moduleName) {
				return $module;
			}
		}
	}
	return '';
}



###############################################################################
# configures all modules
# if not blocked, required and not installed
#
# u=upgrade
# c=configure
# R=remove
# .=nothing
#
# installed blocked		required	newversion	newhwid
# tomte.cfg	tomte.cfg	check		origConfig	origConfig
# yes		yes			yes			yes			yes		.
# yes		yes			yes			yes			no		.
# yes		yes			yes			no			yes		.
# yes		yes			yes			no			no		.
# yes		yes			no			yes			yes		.
# yes		yes			no			yes			no		.
# yes		yes			no			no			yes		.
# yes		yes			no			no			no		.
# yes		no			yes			yes			yes		u
# yes		no			yes			yes			no		u
# yes		no			yes			no			yes		u
# yes		no			yes			no			no		.
# yes		no			no			yes			yes		R
# yes		no			no			yes			no		R
# yes		no			no			no			yes		R
# yes		no			no			no			no		R
# no		yes			yes			yes			yes		.
# no		yes			yes			yes			no		.
# mo		yes			yes			no			yes		.
# no		yes			yes			no			no		.
# no		yes			no			yes			yes		.
# no		yes			no			yes			no		.
# no		yes			no			no			yes		.
# no		yes			no			no			no		.
# no		no			yes			yes			yes		C
# no		no			yes			yes			no		C
# no		no			yes			no			yes		C
# no		no			yes			no			no		C
# no		no			no			yes			yes		.
# no		no			no			yes			no		.
# no		no			no			no			yes		.
# no		no			no			no			no		.

sub configureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		if ($origConfModules{$module}{required} eq 'yes') {
			if ($origConfModules{$module}{reconfigure} eq 'always') {
				# reconfigure modules with 'always' every single time
				reconfigureSingleModule($origConfModules{$module}{name});
			} else {
				configureSingleModule($origConfModules{$module}{name});
			}
		} elsif (($origConfModules{$module}{required} eq 'no') &&
				($localConfModules{$module}{installed} eq 'yes')) {
			removeSingleModule($origConfModules{$module}{name});
		}
	}
}




###############################################################################
# configures a single module
# if not blocked, required and not installed
#
sub configureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	# grub file should always be checked for correct entries if there
	# is a fix available for this system
	if ( (($localConfModules{$module}{installed} eq 'no') ||
		($localConfModules{$module}{installed} eq 'failed') ||
	   	($origConfModules{$module}{postconf} eq 'updateGrub')) &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes') {
		printLog("configure module: $module");
		configureModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' &&
		$localConfModules{$module}{blocked} eq 'no' &&
		$origConfModules{$module}{required} eq 'yes' &&
		$origConfModules{$module}{upgrade} eq 'yes' ) {
		# upgrade if new version or hwid
		printLog("upgrade module: $module");
		upgradeModule($module);
	} elsif ( $localConfModules{$module}{installed} eq 'yes' ) {
		$configuredModules{$module} = 'nothingToDo';
	}
	if ( $localConfModules{$module}{blocked} eq 'yes' ) {
		print "Module $moduleName cannot be installed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
	if ( $origConfModules{$module}{required} eq 'no' ) {
		print "Module $moduleName cannot be installed because:\n";
		print "- it is not required by this system (this is the main reason)\n";
	}
}



###############################################################################
# checks if the conditions to remove a module are met
#
sub removeSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	if ($localConfModules{$module}{blocked} eq 'no') {
		printLog("removing module $module", 'TL');
		removeModule($module);
	}	

	if ( $localConfModules{$module}{blocked} eq 'yes' ) {
		print "Module $moduleName cannot be removed because:\n";
		print "- it is blocked (maybe use 'unblock')\n";
	}
}




###############################################################################
# reconfigures all modules if not blocked and if required even if it is
# already installed
#
sub reconfigureAllModules {
	my $module;
	my $exit_status;
	foreach $module (keys %origConfModules) {
		if ($origConfModules{$module}{required} eq 'yes') {
			reconfigureSingleModule($origConfModules{$module}{name});
		} elsif (($origConfModules{$module}{required} eq 'no') &&
				($localConfModules{$module}{installed} eq 'yes')) {
			removeModule($origConfModules{$module}{name});
		}
	}
}



###############################################################################
# reconfigures a single module if not blocked and if required or prerequisite
# even if it is already installed
#
sub reconfigureSingleModule {
	my $moduleName = shift;
	my $module;
	$module = getSubName($moduleName);
	if ($module eq "") {
		printLog("wrong module name", 'TL');
		return;
	}

	if ( $localConfModules{$module}{blocked} eq 'no' &&
		($origConfModules{$module}{required} eq 'yes' ||
		$origConfModules{$module}{required} eq 'prerequisite')) {
		printLog("configure module: $module");
		configureModule($module);
	} else {
		print "Module: $moduleName cannot be installed because:\n";
	}
	if ( $localConfModules{$module}{blocked} eq 'yes' ) {
		print "- it is blocked (maybe use 'unblock')\n";
	}
	if ( $origConfModules{$module}{required} eq 'no' ) {
		print "- it is not required by this system (this is the main reason)\n";
	}
}



###############################################################################
# blocks a module
#
sub block {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Module $moduleName is already blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Blocking module $moduleName\n";
		print "$moduleName will not be upgraded or reinstalled if removed\n";
		$origConfModules{$module}{blocked} = 'yes';
		printLog("blocking module $moduleName");
		return;
	}
}

###############################################################################
# unblocks a module
#
sub unblock {
	my $moduleName = shift;
	my $module = getSubName($moduleName);
	if ($module eq '') {
		print "Module $moduleName does not exist\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'no') {
		print "Module $moduleName is not blocked\n";
		return;
	}
	if ($localConfModules{$module}{blocked} eq 'yes') {
		print "Unblocking module $moduleName\n";
		print "$moduleName will be upgraded or installed after restart or".
			"next tuxedo-tomte configure or reconfigure\n";
		$origConfModules{$module}{blocked} = 'no';
		printLog("unblocking module $moduleName");
		return;
	}
}


###############################################################################
# configures a module, does no checks
#
sub configureModule {
	my $module = shift;
	$module->($module, 'install');
}


###############################################################################
# remove a module, does no checks
#
sub removeModule {
	my $module = shift;
	$module->($module, 'remove');
}



###############################################################################
# configures a module, does no checks
#
sub upgradeModule {
	my $module = shift;
	$module->($module, 'upgrade');
}



###############################################################################
# starts system programs (if necessary) to activate the module changes
#
sub postConfigure {
	my $sysProgram;
	my $exitStatus;
	my $postConfTrigger = 0;
	my $output;
	my $command;
	printLog("initializing post-configuration");
	foreach $sysProgram (keys %postConfProgram) {
		if ($postConfProgram{$sysProgram}{trigger} == 1 ) {
			printLog("starting $sysProgram");
			$command = $postConfProgram{$sysProgram}{command}.' 2>&1';
			$output = `$command`;
			$exitStatus = $?;
			if ($exitStatus == 0) {
				printLog("success: $postConfProgram{$sysProgram}{command}");
				postSetModulesState($sysProgram, "success");
				$restartSystem = 1;
			} else {
				$postConfTrigger = 1;
				printLog("failed: $postConfProgram{$sysProgram}{command}");
				printLog("returned error code: $exitStatus");
				postSetModulesState($sysProgram, "failed");
			}
		}
	}
	if ($postConfTrigger == 1) {
		startTomteDelayed();
	}
}




###############################################################################
# starts the tuxedo-tomte service for delayed configuration
#
sub startTomteDelayed {
	my $retVal;
	$retVal = system("systemd-run --on-active=1min tuxedo-tomte configure all");
	printLog("starting \"systemd-run tuxedo-tomte configure all\" for delayed configuration");
	printLog("ret value: $retVal");
}



###############################################################################
# sets all modules dependant of some system program to work to status failed
#
sub postSetModulesState {
	my $sysProgram = shift;
	my $status = shift;
	my $module;
	$postConfProgram{$sysProgram}{status} = $status;
	foreach $module (keys %configuredModules) {
		$configuredModules{$module}{status} = $status;
	}
}


###############################################################################
# lists which modules and system programs where installed, configured
# or executed correctly and which not
#
sub listSuccess {
	my $confProgram;
	my $confModule;
	my @failedPrograms;
	my @failedModules;
	my @successModules;
	my @nothingToDoModules;
	my $successOrFailed = 0;

	foreach $confProgram (keys %postConfProgram) {
		if ($postConfProgram{$confProgram}{status} eq "failed") {
			$successOrFailed = 1;
			push(@failedPrograms, $postConfProgram{$confProgram}{command});
		}
	}
	foreach $confModule (keys %configuredModules) {
		if ($configuredModules{$confModule} eq "failed") {
			$successOrFailed = 1;
			push(@failedModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "success") {
			$successOrFailed = 1;
			push(@successModules, $confModule);
		} elsif ($configuredModules{$confModule} eq "nothingToDo") {
			push(@nothingToDoModules, $confModule);
		}
	}
	if (@successModules) {
		print "\nThe following modules have been installed successfully:\n";
		printNameDescriptionModules(@successModules);
	}
	if (@failedModules) {
		print "\nThe following modules have failed to be installed:\n";
		printNameDescriptionModules(@failedModules);
	}
	if (@nothingToDoModules) {
		print "\nThe following modules were already installed:\n";
		printNameDescriptionModules(@nothingToDoModules);
	}
	if (@failedPrograms) {
		print "\nThe following post installation programs have failed:\n";
		printNameDescriptionPrograms(@failedPrograms);
	}
	if (! $successOrFailed) {
		print "\nNothing has been configured\n";
	}
	if ($restartSystem == 1) {
		messageDesktop('Restart required', 'Please restart the system for the changes to take effect.', 2, 'dialog-warning');
		print "\nPlease restart the system for the changes to take effect\n";
	} elsif ( configuredModulesExceptDefault(@successModules) ) {
		messageDesktop('TUXEDO Tomte ready', 'TUXEDO Tomte finished applying all the required fixes available for this system.', 1, 'dialog-information');
	}
}



###############################################################################
# returns 1 if any modules except defined ones were configured
# returns 0 if otherwise
#
sub configuredModulesExceptDefault {
	my @modulesList = @_;
	my @defaultModules = ( 'tuxedorepos', 'tuxedomirrors' );
	foreach ( @defaultModules ) {
		for my $index (reverse 0..$#modulesList) {
			if ($modulesList[$index] =~ /$_/) {
				splice(@modulesList, $index, 1, ());
			}
		}
	}
	if (scalar(@modulesList) > 0) {
		return (1);
	}
	return (0);
}



###############################################################################
# print name and description from modules given as array
#
sub printNameDescriptionModules {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $origConfModules{$element}{name}: $origConfModules{$element}{description}\n";
	}
}


###############################################################################
# print name and description for programs given as array
#
sub printNameDescriptionPrograms {
	my @elements = @_;
	my $element;
	foreach $element (@elements) {
		print "- $element: $postConfProgram{$element}{description}\n";
	}
}


###############################################################################
# show description of module
#
sub moduleDescription() {
	my $moduleName = $argValue{module};
	my $module;
	if ($moduleName) {
		$module = getSubName($moduleName);
		if ( $module ne "" ) {
	    print "$origConfModules{$module}{description}\n";
		} else {
			print "module: $moduleName is not in the modules list\n";
		}
    } else {
		print "Missing module name\n";
	}
}



###############################################################################
# show all modules
#
sub modulesList() {
	my $module;
	foreach $module (keys %origConfModules) {
		print "$origConfModules{$module}{name}\n";
	}
}



###############################################################################
# text to print for help
#
my $USAGE =<<USAGE;
tuxedo-tomte [COMMAND]
  list                        List all installable modules with detailed status
  modules                     List all available modules
  description MODULE          Shows the module description
  configure MODULE ...|all    Configure an unconfigured module
  reconfigure MODULE...|all   Reconfigure a configured module
  block MODULE ...            Block a module
  unblock MODULE ...          Unblock a module
  help                        Prints this message
USAGE


###############################################################################
# TODO to be implemented in the very near future
#  remove MODULE...|ALL        Remove a configured module



###############################################################################
# prints help
#
sub help {
	print "$USAGE\n";
	exit 0;
}


###############################################################################
# checks if root and returns 1 if yes, otherwise 0
#
sub isRoot {
	# check if root
	if( $> != 0 ) {
		return (0);
	}
	return (1);
}


###############################################################################
# checks system requirements, loads configfile
#
sub prepareValues {
	checkRequirements();
	initConfigFile();
	transferConfigValues();
}


###############################################################################
# checks if this is a TUXEDO device
#
sub tuxedoDevice {
	if ($boardname =~ /P65_P67RGRERA/) {
		return (1);
	}
	if ($boardvendor =~ /TUXEDO/) {
		return (1);
	}
	if ($sysvendor =~ /TUXEDO/) {
		return (1);
	}
	if ($boardname =~ /LAPQC71[AB]/) {
		return (1);
	}
	return (0);
}




###############################################################################
###############################################################################
# MAIN PROGRAM

if (!tuxedoDevice()) {
	print 'It seems that this is not a TUXEDO device. Please contact us if this is a mistake';
	exit (0);
}

readOSData();

if (!isOSSupported()) {
	printLog('This OS is not supported', 'TL');
	exit (0);
}

# define for each argvalues procedures
# modify $USAGE if any modifications here

if (@ARGV != 0) {
	my %options;
	@options{"configure", "reconfigure", "remove", "block", "unblock", "update"} = ();
	if (@ARGV > 0) { $argValue{command} = $ARGV[0]; }
	if (@ARGV > 1) { $argValue{module} = $ARGV[1]; }

	if (exists $options{$argValue{command}} && (! isRoot() )) {
		print "You must have root access to use this option\n";
		exit (0);
	}

	if ($argValue{command} eq "list") {
		initLogging();
		prepareValues();
		listStatus();
	} elsif ($argValue{command} eq "modules") {
		modulesList();
	} elsif ($argValue{command} eq "description") {
		moduleDescription();
	} elsif ($argValue{command} eq "help") {
		help();
	} elsif ($argValue{command} eq "FAI") {
		print "Starting tuxedo-tomte in FAI modus\n".
				"This should not be used in a normal situation\n".
				"only when installing a new system with FAI\n";
		$FAI = 1;
		initLogging();
		prepareValues();
		prerequisites();
		configureAllModules();
		postConfigure();
		listSuccess();
		writeConfigFile();
	} elsif ($argValue{command} eq "configure") {
		# check if there is a second argument
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				configureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
			} else {
				configureSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
			}
			printLog('Tomte finished');
		} else {
			print "Module name or \"all\" missing\n";
		}
	} elsif ($argValue{command} eq "remove") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			prerequisites();
			removeSingleModule($argValue{module});
			postConfigure();
			listSuccess();
			writeConfigFile();
			printLog('Tomte finished');
		} else {
			print "Module name or \"all\" missing\n";
		}
		print "remove, does nothing yet\n";
	} elsif ($argValue{command} eq "reconfigure") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			prerequisites();
			if ($argValue{module} eq "all") {
				reconfigureAllModules();
				postConfigure();
				listSuccess();
				writeConfigFile();
			} else {	
				reconfigureSingleModule($argValue{module});
				postConfigure();
				listSuccess();
				writeConfigFile();
			}
			printLog('Tomte finished');
		} else {
			print "Module name or \"all\" missing\n";
		}
	} elsif ($argValue{command} eq "block") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			block($argValue{module});
			writeConfigFile();
			printLog('Tomte finished');
		} else {
			print "Module name missing\n";
		}
	} elsif ($argValue{command} eq "unblock") {
		if ($argValue{module} ne '') {
			initLogging();
			prepareValues();
			unblock($argValue{module});
			writeConfigFile();
			printLog('Tomte finished');
		} else {
			print "Module name missing\n";
		}
	} else {
		print "Unknown command: $argValue{command}\n";
		help();
	}
} else {
	help();
}


